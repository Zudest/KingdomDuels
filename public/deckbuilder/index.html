<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Kingdom Duels Deckbuilder</title>
</head>

<body>
    <div class="container">
        <div class="cards-container">
            <div class="search-container">
                <div class="search-main">
                    <div class="search-logo-link" onclick="window.location.href='/'">
                        <img src="https://kingdomduels.com/img/avatar.png" alt="Kingdom Duels" class="search-logo" title="Go to Kingdom Duels homepage">
                    </div>
                    <input type="text" id="advancedSearch" placeholder="Kingdom Duels card search..." spellcheck="false">
                    <button class="filters-toggle" onclick="toggleFilters()">
                        <span id="toggleIcon">▼</span> Filters
                    </button>
                </div>
                <div class="filters-dropdown" id="filtersDropdown">
                    <div class="filters-row-1">
                        <select id="setFilter">
                            <option value="">Every Set</option>
                        </select>
                        <select id="frameFilter">
                            <option value="">Every Card Frame</option>
                        </select>
                    </div>
                    <div class="filters-row-2">
                    <input type="text" id="nameFilter" placeholder="Filter by card name">
                    <input type="text" id="codeFilter" placeholder="Filter by card id">
                    <input type="text" id="duelistFilter" placeholder="Filter by duelist">
                    </div>
                    <div class="filters-row-3">
                    <select id="attributeFilter">
                    <option value="">Every Attribute</option>
                    </select>
                    <select id="gradeFilter">
                            <option value="">Every Grade</option>
                    </select>
                    <input type="text" id="gradevalFilter" placeholder="Filter by grade value">
                </div>
                <div class="filters-row-4">
                    <input type="text" id="atkFilter" placeholder="Filter by ATK">
                    <input type="text" id="defFilter" placeholder="Filter by DEF">
                    <input type="text" id="bonusatkFilter" placeholder="Filter by Bonus ATK">
                    <input type="text" id="bonusdefFilter" placeholder="Filter by Bonus DEF">
                </div>
                <div class="filters-row-5">
                    <div class="type-filter-container">
                        <input type="text" id="typeFilter" placeholder="Add type (press Enter)">
                        <div class="type-tags" id="typeTags"></div>
                    </div>
                </div>
                    <div class="filter-buttons">
                        <button class="apply-filters-btn" onclick="applyTraditionalFilters()">Apply Filters</button>
                        <button class="clear-filters-btn" onclick="clearFilters()">Clear Filters</button>
                    </div>
                    <div class="syntax-panel">
                        <span class="syntax-toggle" onclick="toggleSyntaxPanel()"><em>Syntax</em></span>
                        <div class="syntax-content" id="syntaxContent">
                            <div class="syntax-section">
                                <strong>Basic Fields:</strong>
                                <div class="syntax-item"><code>name:"Blue-Eyes"</code> - Card name (use quotes for spaces)</div>
                                <div class="syntax-item"><code>frame:monster</code> - Card frame type</div>
                                <div class="syntax-item"><code>set:soe</code> - Card set code</div>
                                <div class="syntax-item"><code>deck:a</code> - Deck type (a = Main Deck, b = Extra Deck)</div>
                                <div class="syntax-item"><code>id:22</code> - Card ID</div>
                                <div class="syntax-item"><code>types:dragon</code> or <code>type:dragon</code> - Card types</div>
                                <div class="syntax-item"><code>duelist:yugi</code> - Duelist name</div>
                                <div class="syntax-item"><code>attribute:light</code> or <code>attrib:light</code> - Attribute</div>
                                <div class="syntax-item"><code>grade:lvl</code> or <code>grade:glyph</code> - Grade type</div>
                            </div>
                            <div class="syntax-section">
                                <strong>Numeric Fields (support >, <, >=, <=, !=):</strong>
                                <div class="syntax-item"><code>atk:3000</code> or <code>atk:>=2000</code> - Attack points</div>
                                <div class="syntax-item"><code>def:2500</code> or <code>def:<=1000</code> - Defense points</div>
                                <div class="syntax-item"><code>bonusatk:500</code> or <code>bonusatk:>0</code> - Field Power Bonus attack points</div>
                                <div class="syntax-item"><code>bonusdef:250</code> or <code>bonusdef:!=0</code> - Field Power Bonus defense points</div>
                                <div class="syntax-item"><code>gradeval:4</code> or <code>gradeval:>6</code> - Grade value</div>
                                <div class="syntax-item"><code>level:4</code> or <code>level:>=8</code> - Level (grade:lvl + gradeval)</div>
                            </div>
                            <div class="syntax-section">
                                <strong>Operators:</strong>
                                <div class="syntax-item"><code>yugi OR kaiba</code> - Either condition</div>
                                <div class="syntax-item"><code>-types:demon</code> - Exclude condition</div>
                                <div class="syntax-item"><code>"exact phrase"</code> - Exact text match</div>
                            </div>
                            <div class="syntax-section">
                                <strong>Examples:</strong>
                                <div class="syntax-item"><code>frame:monster atk>=2500</code> - Strong monsters</div>
                                <div class="syntax-item"><code>duelist:yugi OR duelist:kaiba</code> - Rival characters</div>
                                <div class="syntax-item"><code>types:dragon -types:demon level>4</code> - High level dragons, no demons</div>
                                <div class="syntax-item"><code>attribute:light bonusatk>0</code> - Light cards with field power bonus attack</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-grid" id="cardGrid"></div>
            <p id="limitMessage"></p>
        </div>
        <div class="deck-container">
            <div class="header-with-home">
                <h2>Kingdom Duels Deckbuilder</h2>
                <div class="home-icon" role="img" aria-label="Home" onclick="window.location.href='/'">
                    <img class="home-icon-img" src="../img/iconhome.png" alt="Main Page">
                </div>
            </div>
            <div class="deck-status" id="deckStatus">
                <div class="import-export">
                    <div class="button-group">
                        <button class="button-alt" onclick="document.getElementById('fileInput').click()">Import Deck</button>
                        <button class="button-alt" onclick="exportDeckJSON()">Export Deck</button>
                    </div>
                    <p id="importError">Error importing the deck</p>
                </div>
            </div>
            <div class="deck-section">
                <h4>Main Deck</h4>
                <div id="deckListA"></div>
            </div>
            <div class="deck-section">
                <h4>Extra Deck</h4>
                <div id="deckListB"></div>
            </div>
            <div class="deck-section">
                <h4>Additional Cards</h4>
                <div id="deckListC"></div>
            </div>
            <button class="button-warning" onclick="clearDeck()">Reset Decks</button>
            <button class="button" onclick="showDeckPreview()">Preview</button>
            <button class="button" onclick="saveDeck()">Save for TTS</button>
            <div class="tooltip-container">
                <div class="question-icon" role="img" aria-label="Help">?</div>
                <div class="tooltip" role="tooltip">To import your deck in Tabletop Simulator press "Save for TTS" and save the file into your Steam Saved Objects folder, that is usually in Documents → My Games → Tabletop Simulator → Saves → Saved Objects. Then load the object from the game itself.</div>
            </div>
        </div>
    </div>

    <div class="preview-container" id="previewContainer">
        <span class="close-preview" onclick="closePreview()">×</span>
        <div class="preview-content">
            <div class="preview-grid" id="previewGrid"></div>
        </div>
    </div>

    <div id="cardPopup" class="card-popup" onclick="this.style.display='none'">
        <img id="popupImage" src="" alt="Card preview">
    </div>

    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!--DATA-->
    <script src="data/000_A.js"></script>
    <script src="data/000_T.js"></script>
    <script src="data/001_1.js"></script>
    <script src="data/001_2.js"></script>
    <script src="data/001_3.js"></script>
    <script src="search.js"></script>

    <script>
        // Card and decks limits
        const CARD_DISPLAY_LIMIT = 60;
        const CARDS_PER_PAGE = 60;
        const DECK_LIMITS = {
            A: 30,
            B: 20,
            C: 20
        }
        
        function changePage(newPage) {
            currentPage = newPage;
            renderCards();
        };

        let cardsData = [];
        let deck = [];
        let filteredCards = [...cardsData];
        let currentPage = 1;
        let totalFilteredCards = 0;
        let searcher = null;
        let selectedTypes = [];
        
        function initializeTypeFilter() {
            const typeInput = document.getElementById('typeFilter');
            
            typeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addTypeTag(this.value.trim());
                    this.value = '';
                }
            });
        }
        
        function addTypeTag(type, isNegative = false) {
            if (!type || selectedTypes.some(t => t.value === type && t.negative === isNegative)) {
                return;
            }
            
            selectedTypes.push({ value: type, negative: isNegative });
            renderTypeTags();
        }
        
        function removeTypeTag(index) {
            selectedTypes.splice(index, 1);
            renderTypeTags();
        }
        
        function toggleTypeNegative(index) {
            selectedTypes[index].negative = !selectedTypes[index].negative;
            renderTypeTags();
        }
        
        function renderTypeTags() {
            const container = document.getElementById('typeTags');
            
            container.innerHTML = selectedTypes.map((type, index) => `
                <div class="type-tag ${type.negative ? 'negative' : 'positive'}">
                    <span onclick="toggleTypeNegative(${index})" class="type-prefix" title="Click to toggle include/exclude">
                        ${type.negative ? '-' : '+'}
                    </span>
                    <span class="type-value">${type.value}</span>
                    <span onclick="removeTypeTag(${index})" class="type-remove" title="Remove">×</span>
                </div>
            `).join('');
        }

        const cardImagePath = "https://zudest.github.io/KingdomDuelsDeckbuilder/";
        const defaultCardBack = cardImagePath + "cards/Cardback.png";

        // Card data init (load everything)
        function loadCardsData() {
            cardsData = CARDS_DATABASE.cards;

            // Add new fields
            cardsData.forEach(card => {
                card.cardid = card.set + "-" + card.id;
                card.image = `./cards/${card.set}/${card.id}.jpg`;
                card.fullSet = SET_MAPPING[card.set] || card.set;
            });

            // Load cards from a specific url
            const properUrl = cardImagePath; 
            cardsData.forEach(card => {
                if (card.image && card.image.startsWith("./")) {
                    card.image = card.image.replace("./", properUrl);
                }
            });
            
            filteredCards = [...cardsData];
            initializeFilters();
            
            // Inicializar búsqueda avanzada
            searcher = setupAdvancedSearch(cardsData);
            addAdvancedSearchField();
            initializeTypeFilter();
            
            renderCards();

            // Check for URL search parameter
            checkUrlSearch();
            
            // Check for URL filter after loading cards
            checkUrlFilter();
        }

        // Import functionality
        document.querySelector('.button-group').innerHTML = `
            <button class="button-alt" onclick="document.getElementById('fileInput').click()">Import Deck</button>
            <button class="button-alt" onclick="exportDeckJSON()">Export Deck</button>
        `;

        document.getElementById('fileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            importDeck(file);
        });

        //#########################
        //#### IMPORT / EXPORT ####
        //#########################

        // Import Deck as a JSON file that was previously exported
        async function importDeck(file) {
            const importError = document.getElementById('importError');
            importError.style.display = 'none';

            if (!file) return;

            try {
                const fileContent = await file.text();
                const importedDeck = JSON.parse(fileContent);

                // Verify proper file format
                if (!Array.isArray(importedDeck.cards)) {
                    throw new Error('Invalid file format');
                }

                // Clear current deck
                deck = [];

                // Add each card from the imported file
                importedDeck.cards.forEach(cardCode => {
                    const card = cardsData.find(c => c.cardid === cardCode);
                    if (card) {
                        deck.push({ ...card });
                    }
                });

                renderDeck();
                updateDeckStatus();


            } catch (error) {
                console.error('Error importing the deck:', error);
                importError.style.display = 'block';
            }
        }

        // Generate simulator data for KDSim compatibility
        function generateSimulatorData(deck) {
            const simulatorData = {
                mainDeck: [],
                extraDeck: [],
                otherCards: []
            };
            
            deck.forEach(card => {
                const simCard = {
                    cardId: card.cardid,
                    name: card.name,
                    type: card.frame,
                    description: "",
                    image: card.image
                };
                
                if (card.deck === 'A') {
                    simulatorData.mainDeck.push(simCard);
                } else if (card.deck === 'B') {
                    simulatorData.extraDeck.push(simCard);
                } else if (card.deck === 'C') {
                    simulatorData.otherCards.push(simCard);
                }
            });
            
            return simulatorData;
        }

        // Export deck as JSON to later import to edit
        function exportDeckJSON() {
            const deckData = {
                cards: deck.map(card => card.cardid),
                simulator: generateSimulatorData(deck)
            };

            const blob = new Blob([JSON.stringify(deckData, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'kingdomduels_deck.json';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        //#################
        //#### FILTERS ####
        //#################

        function initializeFilters() {
            const sets = [...new Set(cardsData.map(card => card.fullSet))].sort();
            const frames = [...new Set(cardsData.map(card => card.frame))].sort();
            const attributes = [...new Set(cardsData.filter(card => card.attribute).map(card => card.attribute))].sort();
            const grades = [...new Set(cardsData.filter(card => card.grade).map(card => card.grade))].sort();

            const setFilter = document.getElementById('setFilter');
            const frameFilter = document.getElementById('frameFilter');
            const attributeFilter = document.getElementById('attributeFilter');
            const gradeFilter = document.getElementById('gradeFilter');

            setFilter.innerHTML = '<option value="">Every Set</option>';
            frameFilter.innerHTML = '<option value="">Every Card Frame</option>';
            attributeFilter.innerHTML = '<option value="">Every Attribute</option>';
            gradeFilter.innerHTML = '<option value="">Every Grade</option>';

            sets.forEach(set => {
                const option = document.createElement('option');
                option.value = set;
                option.textContent = set;
                setFilter.appendChild(option);
            });

            frames.forEach(frame => {
                const option = document.createElement('option');
                option.value = frame;
                option.textContent = frame;
                frameFilter.appendChild(option);
            });

            attributes.forEach(attribute => {
                const option = document.createElement('option');
                option.value = attribute;
                option.textContent = attribute.toUpperCase();
                attributeFilter.appendChild(option);
            });

            grades.forEach(grade => {
                const option = document.createElement('option');
                option.value = grade;
                option.textContent = grade.toUpperCase();
                gradeFilter.appendChild(option);
            });
        }

        function applyFilters() {
            const advancedQuery = document.getElementById('advancedSearch');
            
            if (advancedQuery && advancedQuery.value.trim()) {
                // Solo usar búsqueda avanzada
                const results = searcher.search(advancedQuery.value);
                filteredCards = results;
                totalFilteredCards = results.length;
                currentPage = 1;
            } else {
                // Sin filtros, mostrar todo
                filteredCards = [...cardsData];
                totalFilteredCards = filteredCards.length;
                currentPage = 1;
            }

            renderCards();
        }
        
        function applyTraditionalFilters() {
            const query = buildQueryFromFilters();
            const advancedQuery = document.getElementById('advancedSearch');
            
            if (query) {
                advancedQuery.value = query;
                updateUrlSearch(query);
                applyFilters();
            }
        }
        
        function clearFilters() {
            // Limpiar todos los filtros tradicionales
            document.getElementById('nameFilter').value = '';
            document.getElementById('codeFilter').value = '';
            document.getElementById('duelistFilter').value = '';
            document.getElementById('typeFilter').value = '';
            document.getElementById('setFilter').value = '';
            document.getElementById('frameFilter').value = '';
            document.getElementById('attributeFilter').value = '';
            document.getElementById('gradeFilter').value = '';
            document.getElementById('gradevalFilter').value = '';
            document.getElementById('atkFilter').value = '';
            document.getElementById('defFilter').value = '';
            document.getElementById('bonusatkFilter').value = '';
            document.getElementById('bonusdefFilter').value = '';
            
            // Limpiar types seleccionados
            selectedTypes = [];
            renderTypeTags();
            
            // Limpiar búsqueda avanzada
            document.getElementById('advancedSearch').value = '';
            
            // Limpiar URL
            updateUrlSearch('');
            
            // Aplicar cambios
            applyFilters();
        }
        
        function buildQueryFromFilters() {
            const nameFilter = document.getElementById('nameFilter').value.trim();
            const codeFilter = document.getElementById('codeFilter').value.trim();
            const duelistFilter = document.getElementById('duelistFilter').value.trim();
            const setFilter = document.getElementById('setFilter').value;
            const frameFilter = document.getElementById('frameFilter').value;
            const attributeFilter = document.getElementById('attributeFilter').value;
            const gradeFilter = document.getElementById('gradeFilter').value;
            const gradevalFilter = document.getElementById('gradevalFilter').value.trim();
            const atkFilter = document.getElementById('atkFilter').value.trim();
            const defFilter = document.getElementById('defFilter').value.trim();
            const bonusatkFilter = document.getElementById('bonusatkFilter').value.trim();
            const bonusdefFilter = document.getElementById('bonusdefFilter').value.trim();
            
            const queryParts = [];
            
            if (nameFilter) {
                // Si el nombre tiene espacios, usar comillas
                if (nameFilter.includes(' ')) {
                    queryParts.push(`"${nameFilter}"`); 
                } else {
                    queryParts.push(nameFilter);
                }
            }
            if (frameFilter) {
                // Mapear valores del dropdown a términos de búsqueda
                let frameSearchTerm = frameFilter;
                if (frameFilter === 'Alter Monster') frameSearchTerm = 'Alter';
                else if (frameFilter === 'Fusion Monster') frameSearchTerm = 'Fusion';
                else if (frameFilter === 'Ritual Monster') frameSearchTerm = 'Ritual';
                else if (frameFilter === 'Integration Monster') frameSearchTerm = 'Integration';
                else if (frameFilter === 'Token Monster') frameSearchTerm = 'Token';
                
                // Si el frame tiene espacios, usar comillas
                if (frameSearchTerm.includes(' ')) {
                    queryParts.push(`frame:"${frameSearchTerm}"`);
                } else {
                    queryParts.push(`frame:${frameSearchTerm}`);
                }
            }
            if (attributeFilter) {
                queryParts.push(`attribute:${attributeFilter}`);
            }
            if (gradeFilter) {
                queryParts.push(`grade:${gradeFilter}`);
            }
            if (gradevalFilter) {
                queryParts.push(`gradeval:${gradevalFilter}`);
            }
            if (atkFilter) {
                queryParts.push(`atk:${atkFilter}`);
            }
            if (defFilter) {
                queryParts.push(`def:${defFilter}`);
            }
            if (bonusatkFilter) {
                queryParts.push(`bonusatk:${bonusatkFilter}`);
            }
            if (bonusdefFilter) {
                queryParts.push(`bonusdef:${bonusdefFilter}`);
            }
            
            // Procesar types múltiples
            if (selectedTypes.length > 0) {
                selectedTypes.forEach(type => {
                    if (type.value.includes(' ')) {
                        queryParts.push(`${type.negative ? '-' : ''}types:"${type.value}"`);
                    } else {
                        queryParts.push(`${type.negative ? '-' : ''}types:${type.value}`);
                    }
                });
            }
            
            if (setFilter) {
                // Convertir nombre completo a código
                const setCode = Object.keys(SET_MAPPING).find(key => SET_MAPPING[key] === setFilter);
                if (setCode) {
                    queryParts.push(`set:${setCode}`);
                } else {
                    queryParts.push(`set:${setFilter}`);
                }
            }
            if (duelistFilter) {
                // Si el duelist tiene espacios, usar comillas
                if (duelistFilter.includes(' ')) {
                    queryParts.push(`duelist:"${duelistFilter}"`);
                } else {
                    queryParts.push(`duelist:${duelistFilter}`);
                }
            }
            if (codeFilter) {
                queryParts.push(`id:${codeFilter}`);
            }
            
            return queryParts.join(' ');
        }
        
        // Check for URL search parameter
        function checkUrlSearch() {
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            
            if (searchQuery) {
                const advancedSearchField = document.getElementById('advancedSearch');
                if (advancedSearchField) {
                    advancedSearchField.value = decodeURIComponent(searchQuery);
                    applyFilters();
                }
            }
        }
        
        // Update URL when search changes
        function updateUrlSearch(query) {
            const url = new URL(window.location);
            if (query && query.trim()) {
                url.searchParams.set('search', encodeURIComponent(query));
            } else {
                url.searchParams.delete('search');
            }
            
            // Update URL without reloading page
            window.history.replaceState({}, '', url);
        }
        
        function onAdvancedSearchChange() {
            const query = document.getElementById('advancedSearch').value;
            updateUrlSearch(query);
            applyFilters();
        }

        // Check and apply URL Set filter (filter by set directly on the url)
        function checkUrlFilter() {
            // Remove the # from the hash if it exists
            const hash = window.location.hash.replace('#', '');

            if (hash) {
                // Try to find a matching set
                const setFilter = document.getElementById('setFilter');
                const matchingSet = Array.from(setFilter.options)
                    .find(option => option.value.toLowerCase().includes(hash.toLowerCase()));

                if (matchingSet) {
                    setFilter.value = matchingSet.value;
                    applyFilters();
                }
            }
        }

        //################
        //#### RENDER ####
        //################

        function renderCards() {
            const cardGrid = document.getElementById('cardGrid');
            cardGrid.innerHTML = '';

            // Si no se ha establecido totalFilteredCards, usar la longitud actual
            if (totalFilteredCards === 0) {
                totalFilteredCards = filteredCards.length;
            }
            
            // Calcular páginas
            const totalPages = Math.ceil(totalFilteredCards / CARDS_PER_PAGE);
            const startIndex = (currentPage - 1) * CARDS_PER_PAGE;
            const endIndex = Math.min(startIndex + CARDS_PER_PAGE, totalFilteredCards);
            
            // Mostrar solo las cartas de la página actual
            const cardsToShow = filteredCards.slice(startIndex, endIndex);

            cardsToShow.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.innerHTML = `
                    <img src="${card.image}" alt="${card.name}">
                    <div class="card-info">
                        <span class="card-title">${card.name}</span></br>
                        <span class="card-details">${card.types}<br/>${card.cardid}</span>
                    </div>
                `;
                cardElement.onclick = () => addToDeck(card);
                cardElement.oncontextmenu = (e) => showCardPopup(e, card.image);
                cardGrid.appendChild(cardElement);
            });

            // Actualizar mensaje y controles de paginación
            updatePaginationControls(totalPages);
        }
        
        function updatePaginationControls(totalPages) {
            const messageElement = document.getElementById('limitMessage');
            const startCard = (currentPage - 1) * CARDS_PER_PAGE + 1;
            const endCard = Math.min(currentPage * CARDS_PER_PAGE, totalFilteredCards);
            
            let paginationHTML = '';
            
            if (totalPages > 1) {
                paginationHTML = `
                    <div class="pagination-controls" style="margin-top: 15px; text-align: center;">
                        <button onclick="changePage(1)" ${currentPage === 1 ? 'disabled' : ''}>First</button>
                        <button onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>
                        <span style="margin: 0 15px;">Page ${currentPage} of ${totalPages}</span>
                        <button onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>
                        <button onclick="changePage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>Last</button>
                    </div>
                `;
            }
            
            messageElement.style.display = 'block';
            messageElement.innerHTML = `
                Showing ${startCard}-${endCard} of ${totalFilteredCards} cards
                ${paginationHTML}
            `;
        }
        
        // Función para toggle de filtros
        function toggleFilters() {
            const dropdown = document.getElementById('filtersDropdown');
            const icon = document.getElementById('toggleIcon');
            
            if (dropdown.style.display === 'none' || !dropdown.style.display) {
                dropdown.style.display = 'block';
                icon.textContent = '▲';
            } else {
                dropdown.style.display = 'none';
                icon.textContent = '▼';
            }
        }

        // Función para toggle del panel de sintaxis
        function toggleSyntaxPanel() {
            const content = document.getElementById('syntaxContent');
            
            if (content.style.display === 'none' || !content.style.display) {
                content.style.display = 'block';
            } else {
                content.style.display = 'none';
            }
        }

        function getDeckCounts() {
            return {
                A: deck.filter(card => card.deck === 'A').length,
                B: deck.filter(card => card.deck === 'B').length,
                C: deck.filter(card => card.deck === 'C').length
            };
        }

        function updateDeckStatus() {
            const counts = getDeckCounts();
            const statusElement = document.getElementById('deckStatus');
            statusElement.innerHTML = `
                Main Deck: ${counts.A}/${DECK_LIMITS.A}<br>
                Extra Deck: ${counts.B}/${DECK_LIMITS.B}
                <div class="import-export">
                    <div class="button-group">
                        <button class="button-alt" onclick="document.getElementById('fileInput').click()">Import Deck</button>
                        <button class="button-alt" onclick="exportDeckJSON()">Export Deck</button>
                    </div>
                    <p id="importError">Error importing the deck</p>
                </div>
            `;
        }

        function addToDeck(card) {
            const counts = getDeckCounts();
            if (card.deck === 'A' && counts.A >= DECK_LIMITS.A) {
                alert(`The Main Deck has reached its limit of ${DECK_LIMITS.A} cards`);
                return;
            }
            if (card.deck === 'B' && counts.B >= DECK_LIMITS.B) {
                alert(`The Extra Deck has reached its limit of ${DECK_LIMITS.B} cards`);
                return;
            }
            if (card.deck === 'C' && counts.C >= DECK_LIMITS.C) {
                alert(`The Token Pile has reached its limit of ${DECK_LIMITS.C} cards`);
                return;
            }

            deck.push(card);
            renderDeck();
            updateDeckStatus();
        }

        function renderDeck() {
            const deckListA = document.getElementById('deckListA');
            const deckListB = document.getElementById('deckListB');
            const deckListC = document.getElementById('deckListC');
            deckListA.innerHTML = '';
            deckListB.innerHTML = '';
            deckListC.innerHTML = '';

            const cardCounts = {};
            deck.forEach(card => {
                cardCounts[card.cardid] = (cardCounts[card.cardid] || 0) + 1;
            });

            // Order the cards depending on deck
            const sortedCards = Object.entries(cardCounts).map(([cardid, count]) => {
                const card = deck.find(c => c.cardid === cardid);
                return { card, count };
            }).sort((a, b) => {
                // First, sort by deck
                if (a.card.deck !== b.card.deck) {
                    return a.card.deck.localeCompare(b.card.deck);
                }

                // If decks are the same, then sort by card type
                if (a.card.types !== b.card.types) {
                    return a.card.types.localeCompare(b.card.types);
                }

                // If card types are also the same, sort by name
                return a.card.name.localeCompare(b.card.name);
            });

            sortedCards.forEach(({ card, count }) => {
                const deckCard = document.createElement('div');
                deckCard.className = 'deck-card';
                deckCard.innerHTML = `
                    <img src="${card.image}" alt="${card.name}">
                    <span>${card.name} (${count})</span>
                    <button onclick="removeFromDeck('${card.cardid}')">x</button>
                `;

                if (card.deck === 'A') {
                    deckListA.appendChild(deckCard);
                } else if (card.deck === 'B') {
                    deckListB.appendChild(deckCard);
                } else {
                    deckListC.appendChild(deckCard);
                }
            });
        }

        function removeFromDeck(cardid) {
            const index = deck.findIndex(card => card.cardid === cardid);
            if (index !== -1) {
                deck.splice(index, 1);
                renderDeck();
                updateDeckStatus();
            }
        }

        //#################
        //#### BUTTONS ####
        //#################
        
        function transformToTTS() {
            const customDeckMapping = {};
            let currentDeckKey = 1;

            const deckGroups = deck.reduce((acc, card) => {
                const deck = card.deck || 'Default';
                if (!acc[deck]) {
                    acc[deck] = [];
                }
                acc[deck].push(card);
                return acc;
            }, {});

            // Sort keys alphabetically in a new ordered object
            const sortedDeckGroups = Object.keys(deckGroups)
                .sort() 
                .reduce((acc, key) => {
                    acc[key] = deckGroups[key];
                    return acc;
                }, {});

            // Each deck group is a different object
            const objectStates = Object.entries(sortedDeckGroups).map(([deckName, cards], deckIndex) => {
                const customDeckMapping = {};

                const containedObjects = cards.map((card, index) => {
                    const cardId = (index + 1) * 100;

                    customDeckMapping[1 + index] = {
                        FaceURL: card.image.replace("./", cardImagePath),
                        BackURL: defaultCardBack,
                        NumHeight: 1,
                        NumWidth: 1,
                        BackIsHidden: true,
                        UniqueBack: false,
                        Type: 1
                    };

                    return {
                        CardID: cardId,
                        Name: "Card",
                        Nickname: card.name,
                        Transform: {
                            posX: 0,
                            posY: 0,
                            posZ: 0,
                            rotX: 0,
                            rotY: 180,
                            rotZ: 180,
                            scaleX: 1,
                            scaleY: 1,
                            scaleZ: 1
                        }
                    };
                });

                return {
                    Name: "DeckCustom",
                    ContainedObjects: containedObjects,
                    DeckIDs: containedObjects.map(obj => obj.CardID),
                    CustomDeck: customDeckMapping,
                    Transform: {
                        posX: deckIndex * 2.2, // Offset each deck horizontally
                        posY: deckIndex * 1,
                        posZ: 0,
                        rotX: 0,
                        rotY: 180,
                        rotZ: 0,
                        scaleX: 1,
                        scaleY: 1,
                        scaleZ: 1
                    }
                };
            });

            return { ObjectStates: objectStates };
        }

        function saveDeck() {
            const outputJson = transformToTTS();

            const jsonString = JSON.stringify(outputJson, null, 4);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'tabletop_simulator_export.json';
            link.click();
        }


        function showDeckPreview() {
            const previewContainer = document.getElementById('previewContainer');
            const previewGrid = document.getElementById('previewGrid');
            previewGrid.innerHTML = '';

            // Order the cards depending on deck
            const sortedDeck = [...deck].sort((a, b) => {
                // First, sort by deck
                if (a.deck !== b.deck) {
                    return a.deck.localeCompare(b.deck);
                }

                // If decks are the same, then sort by card type
                if (a.types !== b.types) {
                    return a.types.localeCompare(b.types);
                }

                // If card types are also the same, sort by name
                return a.name.localeCompare(b.name);
            });

            sortedDeck.forEach(card => {
                const previewCard = document.createElement('div');
                previewCard.className = 'preview-card';
                previewCard.innerHTML = `<img src="${card.image}" alt="${card.name}">`;
                previewGrid.appendChild(previewCard);
            });

            previewContainer.style.display = 'flex';
        }

        function closePreview() {
            document.getElementById('previewContainer').style.display = 'none';
        }

        // Clear deck function
        function clearDeck() {
            if (confirm('Are you sure you want to clear your deck?')) {
                deck = [];
                renderDeck();
                updateDeckStatus();
            }
        }

        // Function to show card popup
        function showCardPopup(event, imageUrl) {
            event.preventDefault(); // Prevent default right-click menu

            const popup = document.getElementById('cardPopup');
            const popupImage = document.getElementById('popupImage');

            // Set image source
            popupImage.src = imageUrl;

            // Position popup near cursor
            popup.style.left = event.pageX + 'px';
            popup.style.top = event.pageY + 'px';

            // Show popup
            popup.style.display = 'block';
        }

        // Add event listener to close popup when clicking outside
        document.addEventListener('click', function (event) {
            const popup = document.getElementById('cardPopup');
            if (event.target !== popup && !popup.contains(event.target)) {
                popup.style.display = 'none';
            }
        });

        //###################
        //#### CORE LOOP ####
        //###################

        // Filter listeners - Solo para búsqueda avanzada
        // Los filtros tradicionales ahora usan botones

        // Run the application
        initializeFilters();
        renderCards();
        updateDeckStatus();

        document.addEventListener('DOMContentLoaded', loadCardsData);

        //##############################################################################################################################

        const SET_MAPPING = {
            "T": "Terrains",
            "A": "Alternatives",
            "SOE": "01 - Seal of Exodia",
            "KOD": "02 - King of Duelists",
            "LEN": "03 - Loose Ends",
            "MLY": "04 - Millennium Legacy",
            "TEG": "05 - The Egyptian Gods",
            "NPH": "06 - Nameless Pharaoh",
        };

        const CARDS_DATABASE = {
            "cards": [
                ...CHAPTER1_ARC1_DUELISTKINGDOM.cards,
                ...CHAPTER1_ARC2_MUSEUM.cards,
                ...CHAPTER1_ARC3_BATTLECITY.cards,
                ...EXTRA_ALTERNATIVES.cards,
                ...EXTRA_TERRAINS.cards
            ]
        };

    </script>
</body>

</html>
